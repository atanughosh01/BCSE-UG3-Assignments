
/* Weiler-Atherton Polygon Clipping Algorithm */

QPoint MainWindow::intersect(int x1, int y1, int x2, int y2,int x3, int y3, int x4, int y4)
{
    y1=ui->frame->height()-y1+1;
    y2=ui->frame->height()-y2+1;
    y3=ui->frame->height()-y3+1;
    y4=ui->frame->height()-y4+1;

    int num1 = (x1*y2 - y1*x2) * (x3-x4) -(x1-x2) * (x3*y4 - y3*x4);
    int den1 = (x1-x2) * (y3-y4) - (y1-y2) * (x3-x4);
    int retx=num1/den1;

    int num2 = (x1*y2 - y1*x2) * (y3-y4) -(y1-y2) * (x3*y4 - y3*x4);
    int den2 = (x1-x2) * (y3-y4) - (y1-y2) * (x3-x4);
    int rety= (ui->frame->height()-num2/den2+1);

    return QPoint(retx,rety);
}

void MainWindow::WAclipCacher(int x1, int y1, int x2, int y2)
{
    vector<QPoint> polygon(this->poly_vertex_list.begin(),this->poly_vertex_list.end());
    int poly_size = polygon.size() - 1;

    this->clipping_poly_list.push_back(qMakePair(QPoint(x1,y1),"vertex"));
    vector<QPair<QPoint, QString>> store;
    int sign = x1 == x2 ? y2 - y1 : x2 - x1;
    bool flag = x1 == x2 ? false : true;

    // i and k are two consecutive indexes
    // (ix,iy),(kx,ky) are the co-ordinate values of the points
    for (int i = 0; i < poly_size; i++)
    {
        // i and k form a line in polygon
        int k = (i+1) % poly_size;
        int ix = polygon[i].x(), iy = polygon[i].y();
        int kx = polygon[k].x(), ky = polygon[k].y();
        int index = findIntersection(true, qMakePair(polygon[k], "vertex"));
        auto it = this->clipped_poly_list.begin() + index;
//        it = (it == this->clipped_poly_list.begin()) ? it = this->clipped_poly_list.end() : it-1;
        // Calculating position of first and second point

        int i_pos,k_pos;
        if(x2==x1 && ix>x1) i_pos=1;
        else if(x2==x1 && ix<x1) i_pos=-1;
        else if(y2==y1 && iy<y1) i_pos=1;
        else i_pos=-1;

        if(x2==x1 && kx>x1) k_pos=1;
        else if(x2==x1 && kx<x1) k_pos=-1;
        else if(y2==y1 && ky<y1) k_pos=1;
        else k_pos=-1;

        if(y1>y2||x1>x2)
        {
            i_pos=(-1)*i_pos;
            k_pos=(-1)*k_pos;
        }

        // Case 1 : When both points are inside
        if (i_pos >= 0  && k_pos >= 0)
        {
            // No intersection points are added
        }

        // Case 2: When only first point is outside
        else if (i_pos < 0  && k_pos >= 0)
        {
            // Point of intersection with edge and the second point is added
            QPoint intPoint = intersect(x1,y1, x2, y2, ix, iy, kx, ky);
            it = this->clipped_poly_list.insert(it, qMakePair(intPoint, "entry"));
            it++;
            auto it1 = this->clipping_poly_list.begin() + findCorrPos(sign, flag, store, qMakePair(intPoint, "entry"));
            it1 = this->clipping_poly_list.insert(it1,qMakePair(intPoint, "entry"));
        }

        // Case 3: When only second point is outside
        else if (i_pos >= 0  && k_pos < 0)
        {
            //Only point of intersection with edge is added
            QPoint intPoint = intersect(x1,y1, x2, y2, ix, iy, kx, ky);
            it = this->clipped_poly_list.insert(it, qMakePair(intPoint, "exit"));
            it++;
            auto it1 = this->clipping_poly_list.begin() + findCorrPos(sign, flag, store, qMakePair(intPoint, "exit"));
            it1 = this->clipping_poly_list.insert(it1,qMakePair(intPoint, "exit"));
        }

        // Case 4: When both points are outside
        else
        {
            //No intersection points are added
        }
    }
    this->clipping_poly_list.insert(this->clipping_poly_list.end(), store.begin(),store.end());
}

void MainWindow::WAclip()
{
    int i=0;
    int clliped_poly_size=this->clipped_poly_list.size(), clliping_poly_size=this->clipping_poly_list.size();
    for(auto &&point : this->clipped_poly_list) {
        if(point.second=="entry") {
            qDebug() << point.first.x() << point.first.y() << point.second;
            vector<QPoint> new_poly;
            new_poly.push_back(point.first);
            int j=i;
            while(true) {
                j = (j+1) % clliped_poly_size;
                auto newPoint = this->clipped_poly_list[j];
                if(newPoint.second!="exit"){
                    qDebug() << newPoint.first.x() << newPoint.first.y() << newPoint.second;
                    new_poly.push_back(newPoint.first);
                }
                else {
                    int index = findIntersection(false, newPoint);
                    while(true) {
                        auto newPoint1 = this->clipping_poly_list[index];
                        qDebug() << newPoint1.first.x() << newPoint1.first.y() << newPoint1.second;
                        index = (index+1) % clliping_poly_size;
                        new_poly.push_back(newPoint1.first);
                        if(point==newPoint1) break;
                    }
                    break;
                }
            }
            this->poly_list.push_back(new_poly);
        }
        ++i;
    }
}

int MainWindow::findCorrPos(int sign, bool xy, vector<QPair<QPoint, QString> > &vec, QPair<QPoint, QString> intPoint)
{
    int i=0;
    if(xy) {
        for (auto && point : vec) {
            if(sign * point.first.x() > sign * intPoint.first.x()) return i;
            ++i;
        }
    }
    else {
        for (auto && point : vec) {
            if(sign * point.first.y() > sign * intPoint.first.y()) return i;
            ++i;
        }
    }
    return i;
}

int MainWindow::findIntersection(bool flag, QPair<QPoint, QString> intPoint)
{
    int i=0;
    if(flag) {
        for (auto && point : this->clipped_poly_list) {
            if(point == intPoint) return i;
            ++i;
        }
    }
    else {
        for (auto && point : this->clipping_poly_list) {
            if(point == intPoint) return i;
            ++i;
        }
    }
    return -1;
}

/*
void MainWindow::on_weilerAtherton_clicked()
{
    vector<QPoint> old_polygon(this->poly_vertex_list.begin(),this->poly_vertex_list.end());

    this->poly_list.clear();
    this->clipped_poly_list.clear();
    this->clipping_poly_list.clear();

    int x_min=this->clipping_window.topLeft().x(),
            x_max=this->clipping_window.bottomRight().x(),
            y_max=this->clipping_window.topLeft().y(),
            y_min=this->clipping_window.bottomRight().y();

    for(auto &&vertex: this->poly_vertex_list) {
        this->clipped_poly_list.push_back(qMakePair(vertex,"vertex"));
    }
    this->clipped_poly_list.pop_back();

    qDebug() << "\n";
    for(auto && poly: clipped_poly_list) {
        qDebug() << poly.first.x() << poly.first.y() << poly.second;
    }

    WAclipCacher(x_min,y_max,x_min,y_min); //Left
    if(this->poly_vertex_list.size()>0)
        WAclipCacher(x_min,y_min,x_max,y_min); //Bottom
    if(this->poly_vertex_list.size()>1)
        WAclipCacher(x_max,y_min,x_max,y_max); //Right
    if(this->poly_vertex_list.size()>1)
        WAclipCacher(x_max,y_max,x_min,y_max); //Top

    rotate(clipped_poly_list.begin(), clipped_poly_list.begin()+1, clipped_poly_list.end());

    qDebug() << "\n";
    for(auto && poly: clipped_poly_list) {
        qDebug() << poly.first.x() << poly.first.y() << poly.second;
    }
    qDebug() << "\n";
    for(auto && poly: clipping_poly_list) {
        qDebug() << poly.first.x() << poly.first.y() << poly.second;
    }
    qDebug() << "\n";

    WAclip();

    this->on_show_grid_clicked();
    this->draw_window();


    this->line_colours[1] = this->clip_colour;
    for(auto && poly: poly_list) {
        this->poly_vertex_list = poly;
        this->drawPolygon();
    }

    this->poly_vertex_list = old_polygon;
}
*/
